/* Generated By:JJTree&JavaCC: Do not edit this line. LTLParser.java */
package org.processmining.analysis.ltlchecker.parser;

import java.io.*;
import java.util.*;
import java.text.*;

/**
 * LTLParser is an parser for the LTL-language used in a LTL checking plugin
 * for the ProM framework.
 *
 * @version 0.3
 * @author HT de Beer
 */
public class LTLParser/*@bgen(jjtree)*/implements LTLParserTreeConstants, LTLParserConstants {/*@bgen(jjtree)*/
  protected JJTLTLParserState jjtree = new JJTLTLParserState();
/* Fields */

    /** attributes contains the by this parser recognized defined
     * attributes.
     */
    ArrayList attributes;

    /** renamings contains the by this parser recognized defined renamings of
     * already defined attributes.
     */
    ArrayList renamings;

    /** formulae contains the by this parser recognized defined formulae.
     */
    TreeMap formulae;

    /** Parameterized formula saves their parameter data.
    */
    TreeMap parameters;

/* Methods */

    public static void main( String[] args ) {
        if (args.length != 1) {
            System.out.println("parseltl has one argument: the name"
                + " of the file to parse.");
        } else {
            parseFile( args[0] );
        };
    }

    public static void parseFile( String filename ) {

        try {
            LTLParser lp = new LTLParser(
                new FileInputStream(filename));
            lp.init();

            lp.parse();
        } catch( ParseException pe ) {
            System.out.println(
                "Error occured during parsing:\n\n\t" +
                pe.getMessage() );
        } catch( IOException e ) {
            System.out.println(
            "Error while reading " + filename + ". Check"
            + " the file(name) and try again.");
        } catch( Exception e ) {
            System.out.println("Unknown error: " + e.getMessage());
//	    e.printStackTrace();
        };
    }

    /** Construct a new LTLParser with new empty sets, before parsing, no
     * attributes, renamings or formulae are defined.
     */
    public void init() {
        attributes  = new ArrayList();
        renamings   = new ArrayList();
        formulae    = new TreeMap();
        parameters  = new TreeMap();
    }

    /** 
     * Does id exists as attribute, renaming or formula? 
     * 
     * @param id The string denoting the identifier to check.
     *
     * @return True if id exists, else false.
     */
    public boolean existsId( String id ) {
        return (
            existsAttribute( id ) ||
            existsRenaming( id ) ||
            existsFormula( id )
            );
    }

    /** 
     * Does id exists as attribute or a renaming? 
     * 
     * @param id The string denoting the identifier to check.
     *
     * @return True if id exists, else false.
     */
    public boolean existsAttribute( String id ) {
        boolean exists = false;
        Iterator i = attributes.iterator();
        Attribute attr;

        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return ( exists || existsRenaming( id ) );
    }

    /** 
     * Does id exists as a renaming? 
     * 
     * @param id The string denoting the identifier to check.
     *
     * @return True if id exists, else false.
     */
    public boolean existsRenaming( String id ) {
        boolean exists = false;
        Iterator i = renamings.iterator();
        Attribute attr;

        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return ( exists );
    }

    /** 
     * Does id exists as formula? 
     * 
     * @param id The string denoting the identifier to check.
     *
     * @return True if id exists, else false.
     */
    public boolean existsFormula( String id ) {
        return formulae.containsKey( id );
    }

    /**
     * Get the list with attributes.
     *
     * @param The list with attributes.
     */
    public ArrayList getAttributes() {
        return this.attributes;
    }

    /** 
     * Get the attribute linked with id. 
     * 
     * @param id The string denoting the identifier to finf the attribute of.
     * THis id is already checked to be an attributeId.
     *
     * @return The attribute of id.
     */
    public Attribute getAttribute( String id ) {
        Iterator i;
        if ( existsRenaming( id ) ) {
            i = renamings.iterator();
        } else {
            i = attributes.iterator();
        };

        boolean exists = false;
        Attribute attr = null;
        // Is possible because there must be an attribue with name equals id,
        // that is the contract of this method.

        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return attr;
    }

    /** Get the formula linked with id.
     * 
     * @param id The id to get the formula for. Id is already checked to
     * contain an formula.
     *
     * @return The formula of id.
     */
    public SimpleNode getFormula( String id ) {
        return (SimpleNode) formulae.get( id );
    }

    /** Get the parameters linked with id.
     * 
     * @param id The id to get the parameters for. Id is already checked to
     * contain a formula, and hencefort a parameterlist, which may be empty.
     *
     * @return The parameterlist of id.
     */
    public ArrayList getParameters( String id ) {
        return (ArrayList) parameters.get( id );
    }

    private ParseException parseError( Token t, String message ) {
    // Create a new parse exception by token t with message.
        return  new ParseException("Parse error at '" + t.image + "' ( " + t.beginLine +
                ", " + t.beginColumn + " ) : " + message);
    }

    /**
     * Get the names of the visible formulae, that is of all formula.
     *
     * @return A array of names of te defined formulae.
     */
    public ArrayList getVisibleFormulaNames( ) {
        ArrayList results = new ArrayList();
        Iterator i = formulae.values().iterator();
        SimpleNode formula;

        while (i.hasNext()) {
            formula = (SimpleNode) i.next();
            if ( formula.getType() == SimpleNode.FORMULA ) {
                results.add( formula.getName( ) );
            };
        };

        return results;
    }

    static private String cutQuotes( Token t ) {
        String s = t.image;
        return s.substring( 1, s.length() - 1);
    }

    private Attribute newAttribute( String value, int kind, Attribute attr) {
        Attribute attribute = null;

        switch ( attr.getType() ) {

            case Attribute.NUMBER :
                attribute = new NumberAttribute( value, kind, attr ); break;

            case Attribute.DATE :
                attribute = new DateAttribute( value, kind, attr ); break;

            case Attribute.STRING :
                attribute = new StringAttribute( value, kind, attr ); break;

            case Attribute.SET :
                attribute = new SetAttribute( value, kind, attr ); break;

        };

        return attribute;
    }

/** 
 * The grammar of the LTL language is defined below as production rules
 * decorated with some context checking in java.
 */
  final public void parse() throws ParseException {
 /*@bgen(jjtree) parse */
  ASTparse jjtn000 = new ASTparse(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KDATE:
        case KFORMULA:
        case KNUMBER:
        case KRENAME:
        case KSET:
        case KSTRING:
        case KSUBFORMULA:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KDATE:
        case KNUMBER:
        case KSET:
        case KSTRING:
          attributeDefinition();
          break;
        case KRENAME:
          renaming();
          break;
        case KFORMULA:
        case KSUBFORMULA:
          formulaDefinition();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(0);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void attributeDefinition() throws ParseException {
 /*@bgen(jjtree) attributeDefinition */
    ASTattributeDefinition jjtn000 = new ASTattributeDefinition(JJTATTRIBUTEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute   attribute;
    Token       idToken;
    Token       datePatternToken;
    int         type = -1;
    int         scope = -1;
    String      name = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KNUMBER:
      case KSET:
      case KSTRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KNUMBER:
          jj_consume_token(KNUMBER);
                      type = Attribute.NUMBER;
          break;
        case KSET:
          jj_consume_token(KSET);
                      type = Attribute.SET;
          break;
        case KSTRING:
          jj_consume_token(KSTRING);
                      type = Attribute.STRING;
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_1(2)) {
          idToken = jj_consume_token(PIID);
                                  scope = Attribute.PI;
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ATEID:
            idToken = jj_consume_token(ATEID);
                                  scope = Attribute.ATE;
            break;
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        name = idToken.image;
        jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (! existsId( name )) {

            // Add a specialized attribute to the list of attributes.
            switch ( type ) {
                case Attribute.NUMBER: {
                    attribute = new NumberAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
                case Attribute.SET: {
                    attribute = new SetAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
                case Attribute.STRING: {
                    attribute = new StringAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
            };


        } else {
            {if (true) throw parseError( idToken, " Identifier is already defined.");}
        };
        break;
      case KDATE:
        jj_consume_token(KDATE);
              type = Attribute.DATE;
        if (jj_2_2(2)) {
          idToken = jj_consume_token(PIID);
                                  scope = Attribute.PI;
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ATEID:
            idToken = jj_consume_token(ATEID);
                                  scope = Attribute.ATE;
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        name = idToken.image;
        jj_consume_token(ASSIGN);
        datePatternToken = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (! existsId( name )) {

            attribute = new DateAttribute( name, scope, type, Attribute.ATTRIBUTE );
            attribute.setDateParser(
                    new SimpleDateFormat( cutQuotes( datePatternToken ) ) );
            attributes.add( attribute );

        } else {
            {if (true) throw parseError( idToken, " Identifier is already defined.");}
        };
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void renaming() throws ParseException {
 /*@bgen(jjtree) renaming */
    ASTrenaming jjtn000 = new ASTrenaming(JJTRENAMING);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token newIdToken, oldIdToken;
    String newName, oldName;
    int scope = -1;
    int type = -1;
    try {
      jj_consume_token(KRENAME);
      if (jj_2_3(2)) {
        oldIdToken = jj_consume_token(PIID);
                               oldName = oldIdToken.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ATEID:
          oldIdToken = jj_consume_token(ATEID);
                               oldName = oldIdToken.image;
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(KAS);
      newIdToken = jj_consume_token(ID);
                           newName = newIdToken.image;
      jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( existsAttribute( oldName ) ) {
            // The attribute is already defined, so it can be renamed

            if ( ! existsId( newName ) ) {
                // The new does not already exists, so it is a good name.

                Attribute renaming = newAttribute( newName,
                        Attribute.ATTRIBUTE, getAttribute( oldName ) );
                renamings.add( renaming );

            } else {
                // The id already exists, so renaming is not possible.

                {if (true) throw parseError( newIdToken, " Identifier is already defined.");}
            };

        } else {
            // The attribute is not (already) defined, so it can not be
            // renamed.

           {if (true) throw parseError( oldIdToken, " Identifier is not a defined"
                            + "attribute.");}
        };
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public SimpleNode formulaDefinition() throws ParseException {
 /*@bgen(jjtree) formulaDefinition */
    ASTformulaDefinition jjtn000 = new ASTformulaDefinition(JJTFORMULADEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token formulaToken;
    ArrayList params = new ArrayList();
    Token descriptionToken;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KFORMULA:
        jj_consume_token(KFORMULA);
                                jjtn000.setType( SimpleNode.FORMULA );
        break;
      case KSUBFORMULA:
        jj_consume_token(KSUBFORMULA);
                                jjtn000.setType( SimpleNode.SUBFORMULA );
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      formulaToken = jj_consume_token(ID);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        params = argList();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
        parameters.put( formulaToken.image, params.clone() );
      jj_consume_token(RPAREN);
      jj_consume_token(ASSIGN);
      descriptionToken = jj_consume_token(DESC_LITERAL);
      jjtn000.setDescription( cutQuotes( descriptionToken ) );
      props(params, formulaToken.image);
      jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( ! existsId( formulaToken.image )) {

            jjtn000.setName( formulaToken );
            formulae.put( formulaToken.image, jjtn000 );
        } else {
            // The name already exists, so give an error
            {if (true) throw parseError( formulaToken, " Identifier is already defined." );}
        };
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList argList() throws ParseException {
 /*@bgen(jjtree) argList */
    ASTargList jjtn000 = new ASTargList(JJTARGLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute argument;
    ArrayList localVars = new ArrayList();
    try {
      argument = arg(localVars);
                                  localVars.add( argument );
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        argument = arg(localVars);
                                      localVars.add( argument );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return localVars;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute arg(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) arg */
    ASTarg jjtn000 = new ASTarg(JJTARG);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token attributeToken;
    Token paramToken;
    Iterator i = localVars.iterator();
    boolean alreadyInLocalVars = false;
    Attribute argument;
    try {
      paramToken = jj_consume_token(ID);
        while ( i.hasNext() && ! alreadyInLocalVars) {
            // Is paramToken already in the local variables?

            argument = (Attribute) i.next();
            if ( argument.getValue().equals( paramToken.image ) ) {
                alreadyInLocalVars = true;
            };
        };

        if ( existsId( paramToken.image ) || alreadyInLocalVars ) {
            // Id already exists in the context or on global scale.

           {if (true) throw parseError( paramToken, " Identifier is already defined or used.");}
        };
      jj_consume_token(COLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        attributeToken = jj_consume_token(ID);
        break;
      case PIID:
        attributeToken = jj_consume_token(PIID);
        break;
      case ATEID:
        attributeToken = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (!  existsAttribute( attributeToken.image ) ) {

            {if (true) throw parseError( attributeToken,  " Identifier is not a defined"
                                + " attribute or a renaming.");}
        };

        // The argument is correct

        {if (true) return newAttribute( paramToken.image, Attribute.ATTRIBUTE,
                        getAttribute( attributeToken.image ) );}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode props(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) Proposition */
  ASTProposition jjtn000 = new ASTProposition(JJTPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PNOT:
      case LALWAYS:
      case LEVENTUALLY:
      case LNEXTTIME:
        unaryProp(localVars, formulaName);
        break;
      case LPAREN:
        binaryProp(localVars, formulaName);
        break;
      case KEXISTS:
      case KFORALL:
        quantification(localVars, formulaName);
        break;
      default:
        jj_la1[11] = jj_gen;
        if (jj_2_4(2)) {
          comparison(localVars);
        } else if (jj_2_5(2)) {
          formulaCall(localVars, formulaName);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setType(SimpleNode.PROPOSITION);
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode unaryProp(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) UnaryProposition */
  ASTUnaryProposition jjtn000 = new ASTUnaryProposition(JJTUNARYPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PNOT:
        jj_consume_token(PNOT);
                  jjtn000.setType( SimpleNode.NOT );
        break;
      case LALWAYS:
        jj_consume_token(LALWAYS);
                  jjtn000.setType( SimpleNode.ALWAYS );
        break;
      case LEVENTUALLY:
        jj_consume_token(LEVENTUALLY);
                  jjtn000.setType( SimpleNode.EVENTUALLY );
        break;
      case LNEXTTIME:
        jj_consume_token(LNEXTTIME);
                  jjtn000.setType( SimpleNode.NEXTTIME );
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LPAREN);
      props(localVars, formulaName);
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode binaryProp(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) BinaryProposition */
  ASTBinaryProposition jjtn000 = new ASTBinaryProposition(JJTBINARYPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      props(localVars, formulaName);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAND:
        jj_consume_token(PAND);
                  jjtn000.setType( SimpleNode.AND );
        break;
      case POR:
        jj_consume_token(POR);
                  jjtn000.setType( SimpleNode.OR );
        break;
      case PIMPLIES:
        jj_consume_token(PIMPLIES);
                  jjtn000.setType( SimpleNode.IMPLIES );
        break;
      case PBIIMPLIES:
        jj_consume_token(PBIIMPLIES);
                  jjtn000.setType( SimpleNode.BIIMPLIES );
        break;
      case LUNTIL:
        jj_consume_token(LUNTIL);
                  jjtn000.setType( SimpleNode.UNTIL );
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      props(localVars, formulaName);
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode quantification(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) Quantification */
    ASTQuantification jjtn000 = new ASTQuantification(JJTQUANTIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute dummy;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KFORALL:
        jj_consume_token(KFORALL);
                      jjtn000.setType( SimpleNode.FORALL );
        break;
      case KEXISTS:
        jj_consume_token(KEXISTS);
                      jjtn000.setType( SimpleNode.EXISTS );
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LBRACKET);
      dummy = dummy(localVars);
        localVars.add( dummy );
        jjtn000.setDummy( dummy );
      jj_consume_token(BAR);
      props(localVars, formulaName);
      jj_consume_token(RBRACKET);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute dummy(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) DummyVar */
    ASTDummyVar jjtn000 = new ASTDummyVar(JJTDUMMYVAR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token attributeToken;
    Token idToken;
    Attribute dum;
    boolean existsAsLocalVar = false;
    Iterator i = localVars.iterator();
    try {
      idToken = jj_consume_token(ID);
        while ( i.hasNext() ) {
            // Check if there is a local variable with name == id

            dum = (Attribute) i.next();
            if ( dum.getValue().equals( idToken.image ) ) {
                existsAsLocalVar = true;
            };
        };
        if ( existsId( idToken.image ) || existsAsLocalVar ) {
            // Id exists as global definition or as local var

            {if (true) throw parseError( idToken,  " Identifier is already in use in the local" +
                    " context.");}
        };
      jj_consume_token(COLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        attributeToken = jj_consume_token(ID);
        break;
      case PIID:
        attributeToken = jj_consume_token(PIID);
        break;
      case ATEID:
        attributeToken = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( ! existsAttribute( attributeToken.image ) ) {
            {if (true) throw parseError( attributeToken, " Identifier is not a defined"
                                + " attribute or a renaming.");}
        } else if (
                ! (getAttribute( attributeToken.image ).getType() == Attribute.SET)
                ) {

                    // error, quantification must over sets
                {if (true) throw parseError( attributeToken, " Identifier is not a set." );}

        };

        // Attribute exists and is of tye set:

        {if (true) return newAttribute( idToken.image, Attribute.ATTRIBUTE,
                                    getAttribute( attributeToken.image ) );}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode comparison(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Comparison */
    ASTComparison jjtn000 = new ASTComparison(JJTCOMPARISON);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute attribute;
    Token tok;
    int type;
    TreeSet strings = new TreeSet();
    try {
      attribute = attributeId(localVars);
        type = attribute.getType();
        jjtn000.setAttribute( attribute );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case LT:
      case EQ:
      case LE:
      case GE:
      case NE:
      case REQ:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          jj_consume_token(EQ);
                          jjtn000.setType( SimpleNode.EQUAL );
          break;
        case NE:
          jj_consume_token(NE);
                          jjtn000.setType( SimpleNode.NOTEQUAL );
          break;
        case LE:
          jj_consume_token(LE);
                          jjtn000.setType( SimpleNode.LESSOREQUAL );
          break;
        case GE:
          jj_consume_token(GE);
                          jjtn000.setType( SimpleNode.BIGGEROREQUAL );
          break;
        case LT:
          jj_consume_token(LT);
                          jjtn000.setType( SimpleNode.LESSER );
          break;
        case GT:
          jj_consume_token(GT);
                          jjtn000.setType( SimpleNode.BIGGER );
          break;
        case REQ:
          tok = jj_consume_token(REQ);
                    if ( type != Attribute.STRING) {
                        // this operator does not exists then
                        {if (true) throw parseError( tok,
                            " Identifier is not a string."
                        );}
                    } else {
                        jjtn000.setType( SimpleNode.REGEXPEQUAL );
                    };
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        expr(type, localVars, attribute);
        break;
      case KIN:
        tok = jj_consume_token(KIN);
                    if ( type != Attribute.SET) {
                        // this operator does not exists then
                        {if (true) throw parseError( tok,
                            " Identifier is not a set."
                        );}
                    } else {
                        jjtn000.setType( SimpleNode.IN );
                    };
        jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          strings = stringList();
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
          jjtn000.setStrings( strings );
        jj_consume_token(RBRACKET);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode formulaCall(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) FormulaCall */
    ASTFormulaCall jjtn000 = new ASTFormulaCall(JJTFORMULACALL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token formulaToken;
    ArrayList values = new ArrayList();
    try {
      formulaToken = jj_consume_token(ID);
        if (! existsFormula( formulaToken.image ) ) {
            {if (true) throw parseError( formulaToken, " Identifier is not a defined formula.");}
        } else if ( formulaName.equals( formulaToken.image ) ) {
            // Recursion is forbidden, so if the name of this call is to the
            // function in which is call is placed, it is wrong.
            {if (true) throw parseError( formulaToken, " Recursion of formulae is not" +
                                " allowed. If you want to apply" +
                                " staterecursion, use [] and _O." +
                                " ( See the manual for more details.)");}
        } else {
            jjtn000.setName( formulaToken.image );
        };
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case STRING_LITERAL:
      case PIID:
      case ATEID:
      case ID:
        values = valList(formulaToken.image, localVars);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setType( SimpleNode.USEFORMULA );
        if (
            values.size() !=
            ((ArrayList) parameters.get( formulaToken.image )).size()
            ) {
                {if (true) throw parseError( formulaToken, " Defined number of"

                + " parameters not equal to the number of arguments"
                + " applied here.");}
        };
        jjtn000.setValues( values );
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList valList(String formula, ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Values */
    ASTValues jjtn000 = new ASTValues(JJTVALUES);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);ArrayList paramsOfFormula = (ArrayList) parameters.get( formula );
    int paramOrder = 0;
    Attribute param;
    Attribute value;
    ArrayList values = new ArrayList();
    try {
        if ( !( paramsOfFormula.size() <= 0 ) ) {
            param = (Attribute) paramsOfFormula.get( paramOrder );
        } else {
            param = null;
        };
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PIID:
      case ATEID:
      case ID:
        value = valId(param, localVars);
        break;
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case STRING_LITERAL:
        value = literal(param);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        paramOrder++;
        values.add( value );
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_3;
        }
          param = (Attribute) paramsOfFormula.get( paramOrder );
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PIID:
        case ATEID:
        case ID:
          value = valId(param, localVars);
          break;
        case INTEGER_LITERAL:
        case REAL_LITERAL:
        case STRING_LITERAL:
          value = literal(param);
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            paramOrder++;
            values.add( value );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return values;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public TreeSet stringList() throws ParseException {
 /*@bgen(jjtree) StringList */
    ASTStringList jjtn000 = new ASTStringList(JJTSTRINGLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);TreeSet strings = new TreeSet();
    Token st;
    String s;
    try {
      st = jj_consume_token(STRING_LITERAL);
      strings.add( cutQuotes( st ) );
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        st = jj_consume_token(STRING_LITERAL);
          strings.add( cutQuotes( st ) );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return strings;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute attributeId(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token id;
    Attribute result;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        id = jj_consume_token(ID);
        break;
      case PIID:
        id = jj_consume_token(PIID);
        break;
      case ATEID:
        id = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        Iterator i = localVars.iterator();
        boolean found = false;
        Attribute attr = null;

        while ( i.hasNext() && (! found )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id.image ) ) {
                found = true;
            };
        };

        if ( (! existsAttribute( id.image )) && (! found )) {
            {if (true) throw parseError( id, " Identifier is not a defined attribute.");}
        };
        if ( found ) {
            result = attr;
        } else {
            result = getAttribute( id.image );
        };

        {if (true) return result;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute valId(Attribute param, ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) ValueAttribute */
    ASTValueAttribute jjtn000 = new ASTValueAttribute(JJTVALUEATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token id;
    Attribute val = null;
    Iterator i = localVars.iterator();
    boolean found = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        id = jj_consume_token(ID);
        break;
      case PIID:
        id = jj_consume_token(PIID);
        break;
      case ATEID:
        id = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        while ( ( i.hasNext() ) && ( ! found ) ) {
            val = (Attribute) i.next();
            if ( val.getValue().equals( id.image ) ) {
                found = true;
            };
        };
        if ( found && ( ! localVars.isEmpty()) ) {
            if ( ! ( val.getType() == param.getType() ) ) {
                {if (true) throw parseError( id,
                    " Identifier has not the right type.");}
            }
        } else if (! existsAttribute( id.image ) ) {
            {if (true) throw parseError( id, " Identifier is not a local parameter in this context.");}
        } else {
            // It is a `global' par
            val = getAttribute( id.image ) ;
        };

        {if (true) return val;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute literal(Attribute param) throws ParseException {
 /*@bgen(jjtree) Literal */
    ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token tok;
    Attribute result = null;
    String attribute = param.getAttributeId();
    int type = getAttribute( attribute ).getType();
    SimpleDateFormat sdf = new SimpleDateFormat();
    Date date;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        tok = jj_consume_token(STRING_LITERAL);
            if ( type == Attribute.STRING ) {
                result = (StringAttribute) newAttribute(
                    cutQuotes( tok ),
                    Attribute.LITERAL,
                    param);
            } else if ( type == Attribute.DATE ) {
                try {
                    // check if date literal can be parsed as specified
                    sdf =  param.getDateParser();
                    date = sdf.parse( cutQuotes( tok ) );
                    result = (DateAttribute) newAttribute(
                        cutQuotes( tok ),
                        Attribute.LITERAL,
                        param);

                } catch( Exception pe ) {
                    {if (true) throw parseError( tok, " Unable to parse this as a date" +
                        " given definition '" + sdf.toPattern() +
                        "'."
                        );}
                };
            } else if ( type == Attribute.SET ) {
                result = (SetAttribute) newAttribute(
                    cutQuotes( tok ),
                    Attribute.LITERAL,
                    param);
            } else {
                {if (true) throw parseError( tok, " Type mismatch.");}
            };
        break;
      case INTEGER_LITERAL:
        tok = jj_consume_token(INTEGER_LITERAL);
            if ( ! ( type == Attribute.NUMBER ) ) {
                {if (true) throw parseError( tok, "Not expexted a integer" );}
            };
            result = (NumberAttribute) newAttribute(
                tok.image,
                Attribute.LITERAL,
                param);
        break;
      case REAL_LITERAL:
        tok = jj_consume_token(REAL_LITERAL);
            if ( ! ( type == Attribute.NUMBER ) ) {
                {if (true) throw parseError( tok,  "Not expexted a floating point number." );}
            }
            result = (NumberAttribute) newAttribute(
                tok.image,
                Attribute.LITERAL,
                param);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return result;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode expr(int type, ArrayList localVars, Attribute lefthandSideAttribute) throws ParseException {
 /*@bgen(jjtree) Expr */
    ASTExpr jjtn000 = new ASTExpr(JJTEXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    Attribute param = null;
    Attribute value;
    Iterator i = localVars.iterator();
    boolean paramExists = false;
    SimpleDateFormat sdf = new SimpleDateFormat();
    Date date;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case LPAREN:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          // - Number
                  t = jj_consume_token(MINUS);
                  jjtn000.setType( SimpleNode.UNMINUS );
          expr(type, localVars, lefthandSideAttribute);
          break;
        case LPAREN:
          // ( Number op Number )
                  t = jj_consume_token(LPAREN);
          expr(type, localVars, lefthandSideAttribute);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
            jj_consume_token(PLUS);
                  jjtn000.setType( SimpleNode.PLUS );
            break;
          case MINUS:
            jj_consume_token(MINUS);
                  jjtn000.setType( SimpleNode.MINUS );
            break;
          case STAR:
            jj_consume_token(STAR);
                  jjtn000.setType( SimpleNode.MULT );
            break;
          case SLASH:
            jj_consume_token(SLASH);
                  jjtn000.setType( SimpleNode.DIV );
            break;
          default:
            jj_la1[27] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          expr(type, localVars, lefthandSideAttribute);
          jj_consume_token(RPAREN);
          break;
        case INTEGER_LITERAL:
          // INT
                  t = jj_consume_token(INTEGER_LITERAL);
            jjtn000.setType( SimpleNode.INT );
            jjtn000.setName( t.image );
            jjtn000.setAttribute(
                (NumberAttribute) newAttribute(
                    t.image,
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
          break;
        case REAL_LITERAL:
          // REAL
                  t = jj_consume_token(REAL_LITERAL);
            jjtn000.setType( SimpleNode.REAL );
            jjtn000.setName( t.image );
            jjtn000.setAttribute(
                (NumberAttribute) newAttribute(
                    t.image,
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        // One of the above choises implies type == number.
        if (! (type == Attribute.NUMBER)) {
            {if (true) throw parseError(  t, " Expected a numerical value.");}
        };

    {if (true) return jjtn000;}
        break;
      case STRING_LITERAL:
        // String-like expression
            t = jj_consume_token(STRING_LITERAL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( type == Attribute.STRING ) {
            jjtn000.setType( SimpleNode.STRING );
            jjtn000.setName( cutQuotes( t ) );
            jjtn000.setAttribute(
                (StringAttribute) newAttribute(
                    cutQuotes( t ),
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
        } else if ( type == Attribute.DATE ) {
            try {
                // check if date literal can be parsed as specified
                sdf = lefthandSideAttribute.getDateParser();
                date = sdf.parse( cutQuotes( t ) );

                jjtn000.setType( SimpleNode.DATESTRING );
                jjtn000.setName( cutQuotes( t ) );
                jjtn000.setAttribute(
                    (DateAttribute) newAttribute(
                        cutQuotes( t ),
                        Attribute.LITERAL,
                        lefthandSideAttribute) );

            } catch( Exception pe ) {
                {if (true) throw parseError( t,  " Unable to parse this as a date" +
                        " given definition '" + sdf.toPattern() +
                        "'." );}
            };
        } else if ( type == Attribute.SET ) {
            jjtn000.setType( SimpleNode.SETSTRING );
            jjtn000.setName( cutQuotes( t ) );
            jjtn000.setAttribute(
                (SetAttribute) newAttribute(
                    cutQuotes( t ),
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
        } else {
            {if (true) throw parseError(t, " Expected a string.");}
        };

        {if (true) return jjtn000;}
        break;
      case PIID:
      case ATEID:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t = jj_consume_token(ID);
          break;
        case PIID:
          t = jj_consume_token(PIID);
          break;
        case ATEID:
          t = jj_consume_token(ATEID);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        while ( i.hasNext() && (! paramExists)) {
            param = (Attribute) i.next();
            if (param.getValue().equals(t.image)) {
                paramExists = true;
            };
        };

        if ( ! existsAttribute( t.image ) ) {
            // t is not a global attribute or renaming
            if ( ! paramExists ) {
                // t is not a local renaming

                {if (true) throw parseError( t, " Identifier is not defined.");}
            } else {
                // param exists, so param is not empty

                if ( !( param.getType() == type ) ) {
                    // Wrong types

                    {if (true) throw parseError( t, " Type mismatch." );}
                } else {
                    // Good types, so build this node

                    jjtn000.setName( t.image );
                    jjtn000.setType( SimpleNode.ATTRIBUTE );
                    jjtn000.setAttribute( param );
                };
            };
        } else {
            // t is a global attribute or renaming

            if ( ! ( getAttribute( t.image ).getType() == type ) ) {
                // Wrong types

                {if (true) throw parseError( t, " Type mismatch." );}
            } else {
                // Good types

                jjtn000.setName( t.image );
                jjtn000.setType( SimpleNode.ATTRIBUTE );
                jjtn000.setAttribute( getAttribute( t.image ) );
            };
        };

        {if (true) return jjtn000;}
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_3R_6() {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    if (jj_scan_token(KIN)) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(REQ)) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_3R_7()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_8()) {
    jj_scanpos = xsp;
    if (jj_3R_9()) return true;
    }
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_5()) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  final private boolean jj_3R_10() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_10()) {
    jj_scanpos = xsp;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  public LTLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x3d4800,0x3d4800,0x190000,0x20000000,0x20000000,0x190800,0x20000000,0x204000,0x40000000,0x0,0x70000000,0x3000,0x0,0x0,0x3000,0x70000000,0x0,0x4000000,0x8000,0x75800000,0x75800000,0x0,0x75800000,0x0,0x70000000,0x70000000,0x5800000,0x0,0x1800000,0x70000000,0x75800000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x80020008,0x80020000,0x78000000,0x0,0x0,0x7c18000,0x0,0x7c18000,0x0,0x0,0x800,0x0,0x800,0x0,0x0,0x0,0x3c0000,0x100008,0x0,0x100008,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[5];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public LTLParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LTLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public LTLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LTLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public LTLParser(LTLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(LTLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[67];
    for (int i = 0; i < 67; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
